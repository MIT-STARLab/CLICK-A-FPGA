#
# Copyright (C) 2009-2012 Chris McClelland
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#===============================================================================
# USB interface
#===============================================================================
# IFCLK
NET "fx2Clk_in" LOC = P123; # C10;
NET "fx2Clk_in" IOSTANDARD = LVTTL;
# PA4/FIFOADR0
#NET "fx2Addr_out[0]" LOC = ; #  A14;  EN EL ESQUEMÁTICO ESTÁ A GROUND EL PIN DE SALIDA DEL CY7
#NET "fx2Addr_out[0]" IOSTANDARD = LVTTL;
# PA5/FIFOADR1
NET "fx2Addr_out[1]" LOC = P104; #  B14;
NET "fx2Addr_out[1]" IOSTANDARD = LVTTL;

# PB0/FD0
NET "fx2Data_io[0]" LOC = P121; #  A2;
NET "fx2Data_io[0]" IOSTANDARD = LVTTL;
# PB1/FD1
NET "fx2Data_io[1]" LOC = P120; #  D6;
NET "fx2Data_io[1]" IOSTANDARD = LVTTL;
# PB2/FD2
NET "fx2Data_io[2]" LOC = P119; #  C6;
NET "fx2Data_io[2]" IOSTANDARD = LVTTL;
# PB3/FD3
NET "fx2Data_io[3]" LOC = P118; #  B3;
NET "fx2Data_io[3]" IOSTANDARD = LVTTL;
# PB4/FD4
NET "fx2Data_io[4]" LOC = P117; #  A3;
NET "fx2Data_io[4]" IOSTANDARD = LVTTL;
# PB5/FD5
NET "fx2Data_io[5]" LOC = P116; #  B4;
NET "fx2Data_io[5]" IOSTANDARD = LVTTL;
# PB6/FD6
NET "fx2Data_io[6]" LOC = P115; #  A4;
NET "fx2Data_io[6]" IOSTANDARD = LVTTL;
# PB7/FD7
NET "fx2Data_io[7]" LOC = P114; #  C5;
NET "fx2Data_io[7]" IOSTANDARD = LVTTL;

# RDY0/SLRD
NET "fx2Read_out" LOC = P105; #  F13;
NET "fx2Read_out" IOSTANDARD = LVTTL;
# PA2/SLOE
#NET "fx2OE_out" LOC = P; #  A15; EL RD y el OE están conectados juntos, uso solo el Read --------------------------------------------------------
#NET "fx2OE_out" IOSTANDARD = LVTTL;
# CTL2/FLAGC
NET "fx2GotData_in" LOC = P111; #  C15;
NET "fx2GotData_in" IOSTANDARD = LVTTL;

# RDY1/SLWR
NET "fx2Write_out" LOC = P101; #  E13;
NET "fx2Write_out" IOSTANDARD = LVTTL;
# CTL1/FLAGB
NET "fx2GotRoom_in" LOC = P112; #  A9;
NET "fx2GotRoom_in" IOSTANDARD = LVTTL;
# PA6/PKTEND
NET "fx2PktEnd_out" LOC = P102; #  C4;
NET "fx2PktEnd_out" IOSTANDARD = LVTTL;


#===============================================================================
# On-board peripheral signals
#===============================================================================
#NET "led_out[0]" LOC = U18;
#NET "led_out[0]" IOSTANDARD = LVTTL;
#NET "led_out[1]" LOC = M14;
#NET "led_out[1]" IOSTANDARD = LVTTL;
#NET "led_out[2]" LOC = N14;
#NET "led_out[2]" IOSTANDARD = LVTTL;
#NET "led_out[3]" LOC = L14;
#NET "led_out[3]" IOSTANDARD = LVTTL;
#NET "led_out[4]" LOC = M13;
#NET "led_out[4]" IOSTANDARD = LVTTL;
#NET "led_out[5]" LOC = D4;
#NET "led_out[5]" IOSTANDARD = LVTTL;
#NET "led_out[6]" LOC = P16;
#NET "led_out[6]" IOSTANDARD = LVTTL;
#NET "led_out[7]" LOC = N12;
#NET "led_out[7]" IOSTANDARD = LVTTL;

## segment a
#NET "sseg_out[0]" LOC = N10;
#NET "sseg_out[0]" IOSTANDARD = LVTTL;
## segment b
#NET "sseg_out[1]" LOC = T12;
#NET "sseg_out[1]" IOSTANDARD = LVTTL;
## segment c
#NET "sseg_out[2]" LOC = R11;
#NET "sseg_out[2]" IOSTANDARD = LVTTL;
## segment d
#NET "sseg_out[3]" LOC = M11;
#NET "sseg_out[3]" IOSTANDARD = LVTTL;
## segment e
#NET "sseg_out[4]" LOC = U13;
#NET "sseg_out[4]" IOSTANDARD = LVTTL;
## segment f
#NET "sseg_out[5]" LOC = U15;
#NET "sseg_out[5]" IOSTANDARD = LVTTL;
## segment g
#NET "sseg_out[6]" LOC = U16;
#NET "sseg_out[6]" IOSTANDARD = LVTTL;
## decimal point
#NET "sseg_out[7]" LOC = M10;
#NET "sseg_out[7]" IOSTANDARD = LVTTL;

#NET "anode_out[0]" LOC = U11;
#NET "anode_out[0]" IOSTANDARD = LVTTL;
#NET "anode_out[1]" LOC = R10;
#NET "anode_out[1]" IOSTANDARD = LVTTL;
#NET "anode_out[2]" LOC = U10;
#NET "anode_out[2]" IOSTANDARD = LVTTL;
#NET "anode_out[3]" LOC = R8;
#NET "anode_out[3]" IOSTANDARD = LVTTL;

## SW0
#NET "sw_in[0]" LOC = A10;
#NET "sw_in[0]" IOSTANDARD = LVTTL;
## SW1
#NET "sw_in[1]" LOC = D14;
#NET "sw_in[1]" IOSTANDARD = LVTTL;
## SW2
#NET "sw_in[2]" LOC = C14;
#NET "sw_in[2]" IOSTANDARD = LVTTL;
## SW3
#NET "sw_in[3]" LOC = P15;
#NET "sw_in[3]" IOSTANDARD = LVTTL;
## SW4
#NET "sw_in[4]" LOC = P12;
#NET "sw_in[4]" IOSTANDARD = LVTTL;
## SW5
#NET "sw_in[5]" LOC = R5;
#NET "sw_in[5]" IOSTANDARD = LVTTL;
## SW6
#NET "sw_in[6]" LOC = T5;
#NET "sw_in[6]" IOSTANDARD = LVTTL;
## SW7
#NET "sw_in[7]" LOC = E4;
#NET "sw_in[7]" IOSTANDARD = LVTTL;


# Edited by Rodrigo Diez from here
#NET "pmod_in"            LOC="T3"   | IOSTANDARD=LVTTL;   # JA1
#NET "pmod_out<0>"        LOC="R3"   | IOSTANDARD=LVTTL;   # JA2
#NET "pmod_out<1>"        LOC="P6"   | IOSTANDARD=LVTTL;   # JA3
#NET "pmod_out<2>"        LOC="N5"   | IOSTANDARD=LVTTL;   # JA4
#NET "pmod_out<3>"        LOC="V9"   | IOSTANDARD=LVTTL;   # JA5
#NET "pmod_out<4>"        LOC="T9"   | IOSTANDARD=LVTTL;   # JA6
#NET "pmod_out<5>"        LOC="V4"   | IOSTANDARD=LVTTL;   # JA7
#NET "pmod_out<6>"        LOC="T4"   | IOSTANDARD=LVTTL;   # JA8

# Node

NET "spi3clk_o" LOC = P16; #  T3;
NET "spi3clk_o" IOSTANDARD = LVTTL;

NET "spi3ncs_o" LOC = P15; #  R3;
NET "spi3ncs_o" IOSTANDARD = LVTTL;

NET "spi3mosi_o" LOC = P17; #  P6;
NET "spi3mosi_o" IOSTANDARD = LVTTL; # 2

NET "wr_o" LOC = P32; # V9;   # este lo estoy usando pero no corresponde, es sólo por ahora
NET "wr_o" IOSTANDARD=LVTTL;#8   # JA6


#NET "fx2Clk_in"        LOC="V9"   | IOSTANDARD=LVTTL; #7  # JA5

#===============================================================================
# Timing constraint of FX2 48MHz clock "fx2Clk_in"
#===============================================================================
NET "fx2Clk_in" TNM_NET = "fx2Clk_in";
TIMESPEC TS_clk = PERIOD "fx2Clk_in" 20.833 ns HIGH 50 %;

# This sledge-hammer approach works, but will also bury any other
#accidental clock domain crosses I might make elsewhere... in other
#words, this is a very very bad idea.
#Created by Constraints Editor (xc6slx45-csg324-3) - 2015/04/22
#TIMESPEC TS_asyncfifo1 = FROM "fx2Clk_in" TO "swled_app_clock_gen_200_my_dcm_clkfx" TIG;
#TIMESPEC TS_asyncfifo2 = FROM "swled_app_clock_gen_200_my_dcm_clkfx" TO "fx2Clk_in" TIG;

# Constraints extracted from names in timing analyzer tool (WRONG!!!)
# Not entirely certain why this one doesn't work...I think it might be
# targeting flipflop names as opposed to signals connecting to them.
#NET "*/U0/xst_fifo_generator/gconvfifo.rf/grf.rf/gntv_or_sync_fifo.gcx.clkx/rd_pntr_gc_*" TIG;
#NET "*/U0/xst_fifo_generator/gconvfifo.rf/grf.rf/gntv_or_sync_fifo.gcx.clkx/wr_pntr_gc_*" TIG;

# Inferred from schematic editor (found FF's straddling clock domains)
# I think this approach is actually correct, but it was a royal PITA
# to determine those net names.  ISE schematic editor, made even more
# hellish by the low-rez screen on this laptop.



# NET "*/U0/xst_fifo_generator/gconvfifo.rf/grf.rf/gntv_or_sync_fifo.gcx.clkx/gsync_stage[1].rd_stg_inst/D*" TIG;
# NET "*/U0/xst_fifo_generator/gconvfifo.rf/grf.rf/gntv_or_sync_fifo.gcx.clkx/gsync_stage[1].wr_stg_inst/D*" TIG;
